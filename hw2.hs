--Хаятов Олег, А3201

--Задание: 
-- Назовем “производной” элемента числового списка разность между следующим в списке и данным элементом. Производной последнего элемента будем считать 0.
-- Например, список производных элементов списка [3,1,2,5,7,6] будет список [-2,1,3,2,-1,0]. Написать функцию maxDeriv :: Real a => [a] -> 
-- Int, которая в заданном списке числовых элементов находит индекс элемента с максимальной “производной”. Например, в вышеприведенном списке таким 
-- индексом будет 2, поскольку элемент с этим индексом имеет максимальную производную - 3.

{-
Ход мыслей (вернее то, как я это сделяль):
1) сперва написал функцию, которая по заданному листу возвращает индекс первого (!) максимального элемента
было довольно муторно, но в итоге она есть. все сделано рекурсией .поддерживается текущий максимальный элемент и его индекс сложность O(n)
в первой реализации индекс текущего элемента поддерживался при помощи передачи длины начального листа и передачи его в аргументы, а затем вычитанием 
из длины текущего списка глубины рекурсии. но это была откровенно глупая идея из-за ассимптотики (length = O(n)), сложного понимания, ввиду чего имеем getMaxIndex
ну и первый максимальный элемент - первый в списке (на плюсах я бы написал INT_MAX)
2)countDeriv, которая как раз и считает производную, была намногопроще и по написанию, и по чтению. Не знаю, нужны ли тут комментарии...
Всё по условию задания. Делим списочек на голову и хвост. Если в какой-то момент хвоста нет (а значит этот элемент в конце),
конкатенируем нолик к предыдущей полученной последовательности, в противном случае всё делаем по заданию. сложность тоже O(n)

To sum up: 
Имеем неплохой код с защитой от глупого человека, подающего на вход пустой список. Вот щас все сделал, а еще и тестики добавлю и
цены этому коду не будет :D
Всё готово, при желании можно будет явно посчитать производную, вызвав countDeriv list [].
-}
module HW2_1 where

maxDeriv :: Real a => [a] -> Int
maxDeriv list
	|null list = error "Empty list. Please einput not empty sequence"
	|otherwise = getMaxIndex (head llist) 0 0 llist where llist = countDeriv list []

countDeriv :: Real a => [a] -> [a] -> [a]
countDeriv (x:xs) prev
	|null xs = prev ++ [0]
	|otherwise = countDeriv xs (prev ++ [head xs - x])

getMaxIndex :: Real a => a -> Int -> Int -> [a] -> Int
getMaxIndex cur ind depth (x:xs) 
	|x > cur = (if (not (null xs)) then getMaxIndex x depth (depth+1) xs else depth)
	|null xs = ind
	|otherwise = getMaxIndex cur ind (depth+1) xs

main = [maxDeriv [3,1,2,5,7,6] == 2, maxDeriv [0] == 0,maxDeriv [1,2,3,4,5] == 0,maxDeriv [5,4,3,2,1] == 4,maxDeriv [4,2,10,2,4,1] == 1]